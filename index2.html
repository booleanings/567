<!DOCTYPE html>
<meta charset="utf-8">

<body>
    <script src="//d3js.org/d3.v5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.7.1/d3-tip.min.js"></script>
    <script>
    var width = 960,
        height = 500,
        padding = 1.5, // separation between same-color nodes
        clusterPadding = 6, // separation between different-color nodes
        maxRadius = 12;

var n = 151, // total number of nodes
    m = 151; // number of distinct clusters

// The largest node for each cluster.
var clusters = new Array(m);


var means = {};
var nodes = [];

// Start function
const start = async function(a, b) {
    var i = 0;
    const data = await d3.json("data-mod.json");
    data.forEach(function(d) {
        d.Category = d.Category;
        d.tenth = +d.tenth;
        // nodes.push(d);
        if (!+d.tenth) {
            currCat = d.Category;
        }
        if (d.Category == "Mean" && +d.tenth) {
            means[currCat] = +d.tenth;
            // console.log("currcat: " + currCat + " d.tenth: " + +d.tenth);
            // var numCircles = +d.tenth / 18.86140;
            var numCircles = 5;
            for(var j = 0; j < numCircles; j++) {
                nodes.push({
                    cluster: currCat,
                    i: i,
                    r: 6,
                    x: Math.cos(i / m * 2 * Math.PI) * 200 + width / 2 + Math.random(),
                    y: Math.sin(i / m * 2 * Math.PI) * 200 + height / 2 + Math.random()
              })
              console.log("numCircles" + numCircles + " d.tenth " + d.tenth);
            }   
        }
        i++;
        return d;
    });
    var simulation = d3.forceSimulation()
        .nodes(data);
    // const forceX = d3.forceX(width / 2).strength(0.015)
    // const forceY = d3.forceY(height / 2).strength(0.015)
    // simulation
    //     .force('x', forceX)
    //     .force('y',  forceY)
    //     .force("charge_force", d3.forceManyBody())
    //     .force("center_force", d3.forceCenter(width/2,height/2));
        
    simulation
      .force("charge",
        d3.forceManyBody()
          .strength(-10)
      )
      .force("x", d3.forceX(width / 2))
      .force("y", d3.forceY(height / 2));
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var i = 0;
    var elem = svg.selectAll('circle')
        .data(nodes)
        .enter();
    var tip = d3.tip()
    .attr('class', 'd3-tip')
    .offset([-10, 0])
    .html(function(d) {
      console.log("D83*$394792374832" + d);
    return "<strong>Spending:</strong><span style='color:blue'>" + d.tenth + "</span> <span style='color:red'>" + d.cluster + "</span>";
  })
    // d3.selectAll("circle").call(tip);
    var node = elem
        .append('circle')
        .attr("cx", function(d) {
            return d.x
        })
        .attr("cy", function(d) {
            return d.y
        })
        .attr("r", function(d) {
            // console.log(d);
            return d.r
        })
        .attr("fill", "green")
        .attr("stroke-width", .1)
        .attr("stroke", "black")
        .attr("opacity", .8)
        .attr("text", function(d) {
            return d.cluster
        })
        .on('mouseover', tip.show)
        .on('mouseout', tip.hide);


    elem.append("text")
        .attr("dx", function(d) {
            return d.x
        })
        .attr("dy", function(d) {
            return d.y
        });
        
svg.call(tip);
    
    svg.selectAll("circle")
     .data(nodes).enter().append("svg:circle")
    // Move d to be adjacent to the cluster node.
function cluster(alpha) {
  return function(d) {
    var cluster = clusters[d.cluster];
    if (cluster === d) return;
    var x = d.x - cluster.x,
        y = d.y - cluster.y,
        l = Math.sqrt(x * x + y * y),
        r = d.radius + cluster.radius;
    if (l != r) {
      l = (l - r) / l * alpha;
      d.x -= x *= l;
      d.y -= y *= l;
      cluster.x += x;
      cluster.y += y;
    }
  };
}
    function tickActions() {
        //update circle positions each tick of the simulation 
        node
            .attr("cx", function(d) {
                return projection([d.Longitude, d.Latitude])[0];
            }).merge(g)
            .attr("cy", function(d) {
                return projection([d.Longitude, d.Latitude])[1];
            }).merge(g);
    }
}
start();

// console.log("AFTER: " + nodes.length)
</script>